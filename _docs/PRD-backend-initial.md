# PRD: Task Management Chatbot Backend API

## 1. Introduction/Overview

*   **Problem:** Users manage their to-do lists by manually clicking buttons and filling out forms, which can be slow and interrupt their workflow.
*   **Solution:** We will introduce a chatbot that allows users to manage their tasks using natural language. This backend API will be the "brain" of the chatbot, interpreting user messages and translating them into actions the application can understand.
*   **Goal:** To create a single, stateless API endpoint that receives the current app state (tasks and chat history), processes the user's latest message, and returns a conversational response along with a list of specific commands for the frontend to execute.

## 2. Goals

*   **Implement a Core API:** Deliver a single, reliable `POST` API endpoint that serves as the communication bridge between the frontend app and the AI logic.
*   **Accurate Intent Recognition:** Accurately interpret user requests to create, update, delete, and toggle the completion status of tasks.
*   **Contextual Conversations:** Provide helpful and context-aware conversational responses. When a user's request is unclear, the bot should ask for clarification instead of failing or guessing incorrectly.
*   **Structured, Predictable Responses:** Ensure the API's JSON response is strictly defined and predictable, so the frontend can reliably parse it to update the user interface.

## 3. User Stories

*   **As a busy user, I want to quickly add a task by typing** `add a task to follow up with the design team tomorrow morning`, so I can capture my to-dos without navigating through multiple screens.
*   **As a user, I want to mark a task complete by saying** `I'm done with the 'submit expense report' task`, so I can easily update my list by referencing the task naturally.
*   **As a user, I want to delete a task by saying** `get rid of the task about booking flights`, so I can clean up my list effortlessly.
*   **As a user with many tasks, when I say** `change the priority of the weekly report to high`, and I have two similar tasks, **I want the bot to ask me which one I mean**, so I don't accidentally modify the wrong task.

## 4. Functional Requirements

#### FR1: API Endpoint
The system must expose a single HTTP API endpoint.
*   **Method:** `POST`
*   **Path:** `/api/chat`

#### FR2: Request Body Structure
The endpoint must accept a JSON object representing the application's state. The most recent message in `chatHistory` will always be from the `user`.

```json
{
  "tasks": [
    {
      "id": "uuid-string-1",
      "title": "Submit expense report",
      "is_completed": false,
      "priority": "medium",
      "creation_date": "2023-10-26T10:00:00Z",
      "deadline": "2023-10-29T17:00:00Z"
    }
  ],
  "chatHistory": [
    { "id": "uuid-string-2", "text": "Hello!", "sender": "bot" },
    { "id": "uuid-string-3", "text": "Mark the expense report as done", "sender": "user" }
  ]
}
```

#### FR3: Response Body Structure
The endpoint must return a JSON object with two top-level keys: `chat_response` and `actions`.
*   `chat_response` (string): The text the bot will display to the user.
*   `actions` (list of objects): A list of zero or more commands for the frontend to execute.

```json
{
  "chat_response": "Okay, I've marked 'Submit expense report' as completed.",
  "actions": [
    {
      "action_type": "toggleTaskCompletion",
      "payload": { "id": "uuid-string-1" }
    }
  ]
}
```

#### FR4: Action Object Structure
Each object in the `actions` list must have an `action_type` (string) and a `payload` (object). The following actions must be supported:

1.  **Create Task**
    *   `action_type`: `"createTask"`
    *   `payload`: A full Task object. The `id` must be generated by the backend.
        ```json
        { "id": "new-backend-generated-uuid", "title": "New Task", ... }
        ```

2.  **Update Task**
    *   `action_type`: `"updateTask"`
    *   `payload`: An object containing the `id` of the task to update and the `updatedTask` object, which is the complete new version of the task.
        ```json
        { "id": "uuid-of-task-to-update", "updatedTask": { "id": "...", "title": "Updated Title", ... } }
        ```

3.  **Delete Task**
    *   `action_type`: `"deleteTask"`
    *   `payload`: An object containing the `id` of the task to delete.
        ```json
        { "id": "uuid-of-task-to-delete" }
        ```

4.  **Toggle Task Completion**
    *   `action_type`: `"toggleTaskCompletion"`
    *   `payload`: An object containing the `id` of the task to toggle.
        ```json
        { "id": "uuid-of-task-to-toggle" }
        ```

#### FR5: Task Creation
*   The system must be able to create one or more tasks from a single user message.
*   The backend is responsible for generating a unique ID (UUID) for each new task.
*   The system should intelligently parse details like `title`, `description`, `priority`, and `deadline` from the user's text. If only a title is provided, other fields can be left as their default values.

#### FR6: Task Identification for Updates/Deletes
To identify an existing task, the system must follow a two-step process:
1.  **Semantic Search:** First, use a text embedding model to search the full task list and find the top 3-5 tasks that are semantically closest to the user's description.
2.  **LLM Decision:** Pass only these candidate tasks to the main LLM to make a final decision on which task to act upon.

#### FR7: Ambiguity Handling
*   If the LLM determines that a request is ambiguous (e.g., multiple candidate tasks are a strong match, or information is missing), it must not perform any action.
*   It must return an empty `actions` list and a `chat_response` that asks the user for clarification (e.g., "I found a few tasks that match. Which one did you mean: 1. 'Team Meeting' or 2. 'Client Meeting'?").

#### FR8: Out-of-Scope Request Handling
*   If a user's message is not related to task management (e.g., "What's the weather like?"), the system must not perform any action.
*   It must return an empty `actions` list and a polite `chat_response` explaining its capabilities (e.g., "I'm sorry, I can only help with managing your tasks.").

#### FR9: Destructive Action Confirmation
*   The system must execute `deleteTask` actions immediately **without** asking for user confirmation. This is because the action is undoable on the frontend.

## 5. Non-Goals (Out of Scope)

*   This backend will **not** handle user authentication or authorization.
*   This backend will **not** have its own database or persistent storage. It is fully stateless.
*   The chatbot will **not** support actions for reordering tasks (`reorderTasks`) or managing time blocks (`updateTimeBlock`).
*   The implementation will **not** involve creating and running embedding models locally.

## 6. Design Considerations

*   The `chat_response` text is a core part of the user experience. The AI's tone should be helpful, concise, and professional.

## 7. Technical Considerations

*   **Language/Framework:** Python 3. The use of **FastAPI** is recommended for its data validation with Pydantic and automatic API documentation.
*   **Core Logic Workflow:** The core logic should be implemented as a state machine using **LangGraph**. The developer should follow the flow described in the project's Mermaid diagram, which visually represents the nodes (Agent, Tools, Executor) and the conditional logic between them.
*   **Key Dependencies:**
    *   `fastapi`, `uvicorn`: For the web server.
    *   `openai`: To interact with the OpenAI API.
    *   `langgraph`: To structure the logic for the LLM interaction.
    *   `pydantic`, `pydantic-settings`: To define data models and manage environment variables.
*   **API Keys:** The `OPENAI_API_KEY` must be stored in a `.env` file, which must be added to `.gitignore`.
*   **AI Models:**
    *   **Main Logic:** `gpt-4.1-nano`
    *   **Semantic Search:** `text-embedding-3-small` (Accessed via API)
*   **Data Models:** Python `Pydantic` models should be created to mirror the Swift data models (`Task`, `ChatMessage`, etc.) for strict data validation.
*   **Error Handling:** The API should handle potential external errors gracefully (e.g., OpenAI API is down) and return a proper HTTP status code (e.g., 503 Service Unavailable) with an informative error message.

## 8. Resolved Questions
This section summarizes key decisions made prior to implementation for the developer's reference.
*   **ID Generation:** New task IDs will be generated by the backend.
*   **Task Updates:** `updateTask` actions will always send the full, updated task object in the payload.
*   **Embedding Model:** We will use OpenAI's `text-embedding-3-small` via API call, not a local model.
*   **Scalability:** We are proceeding with the stateless approach of sending the full task list in each request and will not implement performance optimizations (like a vector store) at this stage.
